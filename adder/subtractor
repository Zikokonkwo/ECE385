
module fa (input logic a, b, c,
           output logic s, c_out
           );
           
    always_comb begin     
        s = a^b^c;
        c_out = (a&b)|(b&c)|(a&c);
        
    end
    
endmodule
//////////////////////////////////////////////////////
module ripple_adder_3 (input logic [2:0] a, b,
                       input logic c_in,
                       output logic [2:0] s,
                       output logic c_out);
                       
    logic c1, c2;

    fa fa0 (.a(a[0]), .b(b[0]), .c(c_in), .s(s[0]), .c_out(c1));
    fa fa1 (.a(a[1]), .b(b[1]), .c(c1), .s(s[1]), .c_out(c2));
    fa fa2 (.a(a[2]), .b(b[2]), .c(c2), .s(s[2]), .c_out(c_out));
    
endmodule
///////////////////////////////////////////////////////
module ripple_adder (
	input  logic  [8:0] a, 
  input  logic  [8:0] b,
	input  logic        cin,
	
	output logic  [8:0] s,
	output logic        cout
);
             
        logic c3, c6; 
        ripple_adder_3 ra4_0 (.a(a[2:0]),   .b(b[2:0]),   .c_in(cin), .s(s[2:0]),   .c_out(c3) );
        ripple_adder_3 ra4_1 (.a(a[5:3]),   .b(b[5:3]),   .c_in(c3),  .s(s[5:3]),   .c_out(c6) );
        ripple_adder_3 ra4_2 (.a(a[8:6]),  .b(b[8:6]),  .c_in(c6),  .s(s[8:6]),  .c_out(cout) );
       
endmodule
